#include "sach.h"

#include <algorithm>
#include <assert.h>
#include <iostream>
#include <sstream>
#include <cstdlib>
#include <random>
#include <boost/thread.hpp>
#include <boost/algorithm/string/predicate.hpp>

using namespace sach;
using std::set;
using std::map;
using std::pair;
using std::string;
using std::cout;
using std::cerr;
using std::endl;
using std::exception;

using boost::asio::ip::tcp;

#define TCP_BUFFER_SIZE 1024

bool sach::operator==(const RoutingTagPair &tp1, const RoutingTagPair &tp2) {
	return tp1.inboundTag == tp2.inboundTag
			&& tp1.outboundTag == tp2.outboundTag;
}

bool sach::operator<(const RoutingTagPair &tp1, const RoutingTagPair &tp2) {
	return tp1.inboundTag < tp2.inboundTag
			|| (tp1.inboundTag == tp2.inboundTag
					&& tp1.outboundTag < tp2.outboundTag);
}

size_t sach::hash_value(const RoutingTagPair &tp) {
	size_t seed = 0;
	boost::hash_combine(seed, tp.inboundTag);
	boost::hash_combine(seed, tp.outboundTag);
	return seed;
}

bool sach::operator==(const SessionKey &key1, const SessionKey &key2) {
	return key1.srcIp == key2.srcIp && key1.srcPort == key2.srcPort
			&& key1.destIp == key2.destIp && key1.destPort == key2.destPort;
}

size_t sach::hash_value(const SessionKey &key) {
	size_t seed = 0;
	boost::hash_combine(seed, key.srcIp);
	boost::hash_combine(seed, key.srcPort);
	boost::hash_combine(seed, key.destIp);
	boost::hash_combine(seed, key.destPort);
	return seed;
}

SessionKey SessionManager::getPacketSessionKey(Packet &p) {
	if (p.inbound) {
		return SocketInfo(p.socket);
	} else {
		return SocketInfo(p.socket.destIp, p.socket.destPort, p.socket.srcIp,
				p.socket.srcPort);
	}
}

bool SessionManager::createOrRefreshSession(SessionKey &key, timestamp_t ts) {
	bool isNewSession = false;

	if (sessions.find(key) == sessions.end()) {
		isNewSession = true;

		sessions[key] = SessionStatus(ts);
	} else {
		SessionStatus &ses = sessions[key];
		ses.lastUpdate = ts;

		isNewSession = ts - ses.lastUpdate > sessionTau;
	}

	return isNewSession;
}

bool SessionManager::isInActiveSession(Packet &p) {
	SessionKey key = getPacketSessionKey(p);
	//return sessions.find(key) != sessions.end() && (p.timestamp - sessions[key].lastUpdate <= sessionTau);
        timestamp_t now = boost::chrono::duration_cast<boost::chrono::milliseconds>(boost::chrono::high_resolution_clock::now().time_since_epoch()).count();
        return sessions.find(key) != sessions.end()
                        && (now - sessions[key].lastUpdate <= sessionTau);
}

bool SessionManager::assignInstance(SessionKey &key, InstanceID &inst) {
	if (sessions.find(key) != sessions.end()) {
		sessions[key].instance = inst;
		return true;
	} else {
		return false;
	}
}

bool SessionManager::retrieveInstance(SessionKey &key, InstanceID &inst) {
	if (sessions.find(key) != sessions.end()) {
		inst = sessions[key].instance;
		return true;
	} else {
		return false;
	}
}

void LoadMonitor::addInstance(InstanceID &inst) {
	if (counters.find(inst) == counters.end()) {
		counters.insert(std::make_pair(inst, std::make_pair(0, 0)));
		counters.insert(std::make_pair(inst, std::make_pair(0.0, 0.0)));
	}
}

void LoadMonitor::removeInstance(InstanceID &inst) {
	counters.erase(inst);
	statistics.erase(inst);
}

void LoadMonitor::resetCounters() {
	for (auto inst = counters.begin(); inst != counters.end(); inst++) {
		inst->second.first = 0;
		inst->second.second = 0;
	}
}

void LoadMonitor::updateTrafficLoads(double durationInSeconds) {
	for (auto inst = counters.begin(); inst != counters.end(); inst++) {
		statistics[inst->first].first = inst->second.first / durationInSeconds;
		statistics[inst->first].second = inst->second.second
				/ durationInSeconds;
	}
}

void LoadMonitor::getTrafficLoads(
		std::map<InstanceID, std::pair<double, double>> &stats) {
	stats.clear();
	stats.insert(statistics.begin(), statistics.end());
}

bool LoadMonitor::incrementCounter(InstanceID &inst, bool inbound) {
	if (counters.find(inst) != counters.end()) {
		if (inbound) {
			counters[inst].first++;
		} else {
			counters[inst].second++;
		}
	}

	// check if the statistics update is triggered
	boost::chrono::high_resolution_clock::time_point now =
			boost::chrono::high_resolution_clock::now();
	double duration = (double) boost::chrono::duration_cast<
			boost::chrono::milliseconds>(now - lastTime).count() / 1000.0;
	if (duration > 1.0) {
		updateTrafficLoads(duration);
		resetCounters();
		lastTime = now;

		return true;
	} else {
		return false;
	}
}

void SessionAwareConsistentHashing::updateBuckets(unsigned int seed,
		std::map<InstanceID, size_t> &slots) {
	buckets.clear();

	for (auto ins = slots.begin(); ins != slots.end(); ins++) {
		for (size_t i = 0; i < ins->second; i++) {
			buckets.push_back(ins->first);
		}
	}

	if (!buckets.empty()) {
		std::default_random_engine gen(seed);
		std::shuffle(buckets.begin(), buckets.end(), gen);
	}

	/* // DBG: to compare the buckets generated by the master and the slave
	cout << "** bucket contents **" << endl;
	for (auto t = buckets.begin(); t != buckets.end(); t++) {
		cout << t->inboundTag << ",";
	}
	cout << endl;
	*/
}

InstanceID SessionAwareConsistentHashing::mapPacketToInstance(Packet &p) {
	InstanceID id;
	SessionKey key = sesManager.getPacketSessionKey(p);
        timestamp_t now = boost::chrono::duration_cast<boost::chrono::milliseconds>(boost::chrono::high_resolution_clock::now().time_since_epoch()).count();
	if (sesManager.isInActiveSession(p)) {
		// update session timestamp and reuse instance id
		//sesManager.createOrRefreshSession(key, p.timestamp);
                sesManager.createOrRefreshSession(key, now);
		sesManager.retrieveInstance(key, id);
	} else {
		assert(!buckets.empty());
		id = buckets[hash_value(key) % buckets.size()];
		/*cout	// DBG
				<< "New instance assignment: "
				<< "key=(" << key.srcIp << ":" << key.srcPort << "->" << key.destIp << ":" << key.destPort << ") " 
				<< "hash=" << hash_value(key) << " "
				<< "bucketSize=" << buckets.size() << " "
				<< "tags=(" << id.inboundTag << "," << id.outboundTag << ")" << endl; */
		// create session and set instance id
		//sesManager.createOrRefreshSession(key, p.timestamp);
                sesManager.createOrRefreshSession(key, now);
		sesManager.assignInstance(key, id);
	}

	return id;
}

LoadBalancer::LoadBalancer(std::string cPort, std::string sIp,
		std::string sPort) :
		 isMaster(true), controlPort(cPort), slaveIp(sIp), slavePort(sPort), sesManager(), loadMonitor(), hashing(
		sesManager) {
	ctlTh = boost::thread(&LoadBalancer::runCtlServer, this);
}
LoadBalancer::LoadBalancer(std::string sPort) :
		isMaster(false), controlPort(""), slaveIp("localHost"), slavePort(
				sPort), sesManager(), loadMonitor(), hashing(sesManager) {
	rmiTh = boost::thread(&LoadBalancer::runRmiServer, this);
}

//WR LB
LoadBalancer::LoadBalancer(std::string cPort, std::string sIp,
                std::string sPort, timestamp_t tauNew) :
                 isMaster(true), controlPort(cPort), slaveIp(sIp), slavePort(sPort), sesManager(), loadMonitor(), hashing(
                sesManager) {
        //WR
        sesManager.setSessionTau(tauNew);
        //WR
        ctlTh = boost::thread(&LoadBalancer::runCtlServer, this);
}
LoadBalancer::LoadBalancer(std::string sPort, timestamp_t tauNew) :
                isMaster(false), controlPort(""), slaveIp("localHost"), slavePort(
                                sPort), sesManager(), loadMonitor(), hashing(sesManager) {
        sesManager.setSessionTau(tauNew);
        rmiTh = boost::thread(&LoadBalancer::runRmiServer, this);
}
// WR End


std::string LoadBalancer::readTcpRequest(boost::asio::ip::tcp::socket &sock) {
	std::stringstream request;
	boost::asio::streambuf requestBuffer;
	boost::asio::read_until(sock, requestBuffer, "#");
	request << &requestBuffer;
	return request.str();
}
std::string LoadBalancer::readTcpReply(boost::asio::ip::tcp::socket &sock) {
	std::stringstream reply;
	boost::asio::streambuf replyBuffer;
	boost::system::error_code error;
	while (boost::asio::read(sock, replyBuffer,
			boost::asio::transfer_at_least(1), error))
		reply << &replyBuffer;
	if (error != boost::asio::error::eof)
		throw boost::system::system_error(error);
	return reply.str();
}

void LoadBalancer::runCtlServer() {
	cout << "ctl server thread created." << endl;	// DBG
	try {
		boost::asio::io_service ioService;

		tcp::acceptor acc(ioService,
				tcp::endpoint(tcp::v4(), std::atoi(controlPort.c_str())));
		while (true) {
			cout << "ctl server waiting for connection." << endl;	// DBG
			tcp::socket sock(ioService);
			acc.accept(sock);
			cout << "ctl server connection accepted." << endl;	// DBG

			try {
				string request = readTcpRequest(sock);
				string reply = handleControlCommand(request);
				boost::asio::write(sock,
						boost::asio::buffer(reply.c_str(), reply.length()));

				cout << "ctl request: " << request << endl; // DBG
				cout << "ctl reply: " << reply << endl; // DBG
			} catch (exception &e1) {
				cerr << "[" << __func__ << "]: " << e1.what() << endl;
			}
		}
	} catch (exception &e) {
		cerr << "[" << __func__ << "]: " << e.what() << endl;
	}
}

void LoadBalancer::runRmiServer() {
	cout << "rmi server thread created." << endl;	// DBG
	try {
		boost::asio::io_service ioService;

		tcp::acceptor acc(ioService,
				tcp::endpoint(tcp::v4(), std::atoi(slavePort.c_str())));
		while (true) {
			cout << "rmi server waiting for connection." << endl;	// DBG
			tcp::socket sock(ioService);
			acc.accept(sock);
			cout << "rmi server connection accepted." << endl;	// DBG
			try {
				string request = readTcpRequest(sock);
				string reply = handleMasterRequest(request);
				boost::asio::write(sock,
						boost::asio::buffer(reply.c_str(), reply.length()));

				cout << "rmi request: " << request << endl; // DBG
				cout << "rmi reply: " << reply << endl; // DBG
			} catch (exception &e1) {
				cerr << "[" << __func__ << "]: " << e1.what() << endl;
			}
		}
	} catch (exception &e) {
		cerr << "[" << __func__ << "]: " << e.what() << endl;
	}
}

std::string LoadBalancer::tcpRequestRespond(std::string reqStr) {
	try {
		if (!isMaster) {
			throw SachException("Slave calling master function.");
		}
		// 1. open socket
		boost::asio::io_service io_service;
		tcp::socket sock(io_service);
		tcp::resolver resolver(io_service);
		boost::asio::connect(sock, resolver.resolve( { slaveIp, slavePort }));

		// 2. write request
		boost::asio::write(sock,
				boost::asio::buffer(reqStr.c_str(), reqStr.length()));
		boost::asio::write(sock, boost::asio::buffer("#", 1));

		// 3. receive reply
		string reply = readTcpReply(sock);

		return reply;
	} catch (exception &e) {
		throw SachException(e.what());
	}
}

std::string LoadBalancer::handleControlCommand(std::string reqStr) {
	if (boost::starts_with(reqStr, "add")) {
		std::stringstream req(reqStr);
		string cmd;
		InstanceID id;
		req >> cmd;
		req >> id.inboundTag;
		req >> id.outboundTag;

		addInstance(id);
		return "ok";
	} else if (boost::starts_with(reqStr, "del")) {
		std::stringstream req(reqStr);
		string cmd;
		InstanceID id;
		req >> cmd;
		req >> id.inboundTag;
		req >> id.outboundTag;

		removeInstanceWithCoolDown(id);
		return "ok";
	} else if (boost::starts_with(reqStr, "active")) {
		std::stringstream req(reqStr);
		string cmd;
		InstanceID id;
		req >> cmd;
		req >> id.inboundTag;
		req >> id.outboundTag;

		return isActive(id) ? "true" : "false";
	} else if (boost::starts_with(reqStr, "rebalance")) {
		balanceLoadsForExistingInstances();
		return "ok";
	} else if (boost::starts_with(reqStr, "stat")) {
		double totalLoad = 0.0;
		map<InstanceID, double> loads;
		collectHistoricalLoads(totalLoad, loads);

		std::stringstream rtn;
		rtn << loads.size() << " ";

		cout << "*** Historical Traffic Statistics (packets/time-window) ***"
				<< endl;
		for (auto it = loads.begin(); it != loads.end(); it++) {
			rtn << it->first.inboundTag << " " << it->first.outboundTag << " "
					<< it->second << " ";
			cout << "(" << it->first.inboundTag << "," << it->first.outboundTag
					<< "): " << it->second << endl;
		}
		cout << "*** End ***" << endl;

		return rtn.str();
	} else {
		cout << "Unknown control command" << endl;
		return "err";
	}
}

std::string LoadBalancer::handleMasterRequest(std::string reqStr) {
	if (boost::starts_with(reqStr, "getStatistics")) {
		return rmiRespondGetStatistics();
	} else if (boost::starts_with(reqStr, "updateHash")) {
		string cmd;
		unsigned int seed;
		size_t numInstances;
		map<InstanceID, size_t> slots;

		std::stringstream req(reqStr);
		req >> cmd;
		req >> seed;
		req >> numInstances;
		while (numInstances-- > 0) {
			InstanceID id;
			size_t slot;
			req >> id.inboundTag;
			req >> id.outboundTag;
			req >> slot;
			slots[id] = slot;
		}

		return rmiRespondUpdateHashFunction(seed, slots);
	} else if (boost::starts_with(reqStr, "addInstance")) {
		std::stringstream req(reqStr);
		string cmd;
		InstanceID id;
		req >> cmd;
		req >> id.inboundTag;
		req >> id.outboundTag;

		return rmiRespondAddInstance(id);
	} else if (boost::starts_with(reqStr, "removeInstance")) {
		std::stringstream req(reqStr);
		string cmd;
		InstanceID id;
		req >> cmd;
		req >> id.inboundTag;
		req >> id.outboundTag;

		return rmiRespondRemoveInstance(id);
	} else {
		cout << "Unknown rmi request command" << endl;
		return "err";
	}
}

/// the request string is "getStatistics"
/// the reply should be "N [id inCount outCount]*
bool LoadBalancer::rmiRequestGetStatistics(
		std::map<InstanceID, std::pair<double, double>> &rmStats) {
	try {
		rmStats.clear();

		std::stringstream reply(tcpRequestRespond("getStatistics"));
		int numInstances;
		reply >> numInstances;
		while (numInstances-- > 0) {
			InstanceID id;
			double inCount, outCount;
			reply >> id.inboundTag;
			reply >> id.outboundTag;
			reply >> inCount;
			reply >> outCount;

			rmStats[id] = std::make_pair(inCount, outCount);
		}

		return true;
	} catch (exception &e) {
		cerr << "[" << __func__ << "]: " << e.what() << endl;
		return false;
	}
}

/// the request string is "updateHash seed N [id slot]*"
/// expect reply is none null string
bool LoadBalancer::rmiRequestUpdateHashFunction(unsigned int seed,
		std::map<InstanceID, size_t> &slots) {
	try {
		std::stringstream req;
		req << "updateHash " << seed << " " << slots.size() << " ";
		for (auto it = slots.begin(); it != slots.end(); it++) {
			req << it->first.inboundTag << " " << it->first.outboundTag << " "
					<< it->second << " ";
		}

		tcpRequestRespond(req.str());

		return true;
	} catch (exception &e) {
		cout << e.what() << endl;
		return false;
	}
}

/// the requset is "addInstance id"
/// expect reply is none null string
bool LoadBalancer::rmiRequestAddInstance(InstanceID &inst) {
	try {
		std::stringstream req;
		req << "addInstance " << inst.inboundTag << " " << inst.outboundTag;

		tcpRequestRespond(req.str());

		return true;
	} catch (exception &e) {
		cout << e.what() << endl;
		return false;
	}
}

/// the requset is "removeInstance id"
/// expect reply is none null string
bool LoadBalancer::rmiRequestRemoveInstance(InstanceID &inst) {
	try {
		std::stringstream req;
		req << "removeInstance " << inst.inboundTag << " " << inst.outboundTag;

		tcpRequestRespond(req.str());

		return true;
	} catch (exception &e) {
		cout << e.what() << endl;
		return false;
	}
}

std::string LoadBalancer::rmiRespondGetStatistics() {
	if (!isMaster) {
		map<InstanceID, std::pair<double, double>> stats;
		loadMonitor.getTrafficLoads(stats);

		std::stringstream reply;
		reply << stats.size() << " ";
		for (auto it = stats.begin(); it != stats.end(); it++) {
			reply << it->first.inboundTag << " " << it->first.outboundTag << " "
					<< it->second.first << " " << it->second.second << " ";
		}

		return reply.str();
	} else {
		return "";
	}
}
std::string LoadBalancer::rmiRespondUpdateHashFunction(unsigned int seed,
		std::map<InstanceID, size_t> &slots) {
	hashing.updateBuckets(seed, slots);
	return "ok";
}

std::string LoadBalancer::LoadBalancer::rmiRespondAddInstance(
		InstanceID &inst) {
	loadMonitor.addInstance(inst);
	return "ok";
}

std::string LoadBalancer::rmiRespondRemoveInstance(InstanceID &inst) {
	loadMonitor.removeInstance(inst);
	return "ok";
}

tag_t LoadBalancer::packetToInstance(Packet &p) {
	InstanceID id = hashing.mapPacketToInstance(p);
	loadMonitor.incrementCounter(id, p.inbound);
	if (coolingDownInstances.find(id) != coolingDownInstances.end()) {
		coolingDownInstances[id] = boost::chrono::high_resolution_clock::now();
	}

	tag_t tag = isMaster ? 
			(p.inbound ? id.inboundTag : p.existingTag) 
		: 
			(p.inbound ? p.existingTag : id.outboundTag);
		
	/*cout <<	// DBG
			(isMaster ? "Master" : "Slave") << 
			" packet:" << 
			p.socket.srcIp << ":" << 
			p.socket.srcPort << "->" <<
			p.socket.destIp << ":" <<
			p.socket.destPort << "@" <<
			(p.inbound ? "inbound" : "outbound") << "#Tag:" <<
			tag << endl;*/
	
	return tag;
}

void LoadBalancer::collectHistoricalLoads(double &totalLoad,
		std::map<InstanceID, double> &loads) {
	map<InstanceID, pair<double, double>> localStats, remoteStats;
	loadMonitor.getTrafficLoads(localStats);
	if (!rmiRequestGetStatistics(remoteStats)) {
		throw SachException("RMI request get statistics failed.");
	}

	loads.clear();
	totalLoad = 0.0;

	for (auto it = localStats.begin(); it != localStats.end(); it++) {
		if (loads.find(it->first) == loads.end()) {
			loads[it->first] = 0.0;
		}
		loads[it->first] += it->second.first;
		totalLoad += it->second.first;
	}
	for (auto it = remoteStats.begin(); it != remoteStats.end(); it++) {
		if (loads.find(it->first) == loads.end()) {
			loads[it->first] = 0.0;
		}
		loads[it->first] += it->second.second;
		totalLoad += it->second.second;
	}
}

void LoadBalancer::normaliseProbabilities(std::map<InstanceID, double> &probs) {
	double totalProb = 0.0;
	for (auto it = probs.begin(); it != probs.end(); it++) {
		totalProb += it->second;
	}
	for (auto it = probs.begin(); it != probs.end(); it++) {
		it->second /= totalProb;
	}
}

void LoadBalancer::updateLoadAssignments(std::map<InstanceID, double> &loads) {
	map<InstanceID, size_t> slots;
	for (auto it = loads.begin(); it != loads.end(); it++) {
		slots[it->first] = it->second * totalSlots;
	}
	unsigned int seed = 1234567;
	if (!rmiRequestUpdateHashFunction(seed, slots)) {
		throw SachException("RMI request update hash function failed.");
	}
	hashing.updateBuckets(seed, slots);
	loadAssignments.swap(loads);
}

void LoadBalancer::balanceLoadsForRemovedInstance(InstanceID &inst) {
	map<InstanceID, double> newLoadAssignments;
	if (instances.empty()) {
		throw SachException("No network function instance available.");
	} else if (instances.size() == 1) { // direct all traffic to the remaining one instance
		newLoadAssignments[*instances.begin()] = 1.0;
		updateLoadAssignments(newLoadAssignments);
	} else {
		map<InstanceID, double> loads;
		double totalLoad = 0.0;
		collectHistoricalLoads(totalLoad, loads);

		for (auto it = instances.begin(); it != instances.end(); it++) {
			if (loads[*it] <= 0.0) { // avoid division by 0
				newLoadAssignments[*it] = 1.0 / (double) (instances.size() - 1);
			} else {
				newLoadAssignments[*it] = totalLoad * loadAssignments[*it]/ ((instances.size() - 1) * loads[*it]);
                                // newLoadAssignments[*it] = (2 - ((instances.size() - 1)* loadAssignments[*it])) / (instances.size() - 1);
			}
		}

		normaliseProbabilities(newLoadAssignments);
		updateLoadAssignments(newLoadAssignments);
	}
}

void LoadBalancer::balanceLoadsForNewInstance(InstanceID &inst) {
	map<InstanceID, double> newLoadAssignments;
	if (instances.size() == 1) { // initial set up
		newLoadAssignments[inst] = 1.0;
		updateLoadAssignments(newLoadAssignments);
	} else {
		map<InstanceID, double> loads;
		double totalLoad = 0.0;
		collectHistoricalLoads(totalLoad, loads);

		loads[inst] = 0.0; // i.e., new instance should not have any historical traffic

		for (auto it = instances.begin(); it != instances.end(); it++) {
			if (loads[*it] <= 0.0) { // avoid division by 0
				newLoadAssignments[*it] = 1.0 / (double) (instances.size() + 1);
			} else {
				newLoadAssignments[*it] = totalLoad * loadAssignments[*it]/ ((instances.size() + 1) * loads[*it]);
                                //newLoadAssignments[*it] = (2 - ((instances.size() + 1)* loadAssignments[*it])) / (instances.size() + 1);
			}
		}

		normaliseProbabilities(newLoadAssignments);
		updateLoadAssignments(newLoadAssignments);
	}
}

void LoadBalancer::balanceLoadsForExistingInstances() {
	map<InstanceID, double> loads;
	double totalLoad = 0.0;
	collectHistoricalLoads(totalLoad, loads);

	map<InstanceID, double> newLoadAssignments;
	for (auto it = instances.begin(); it != instances.end(); it++) {
		if (loads[*it] <= 0.0) { // avoid division by 0
			newLoadAssignments[*it] = 1.0 / (double) instances.size();
		} else {
			newLoadAssignments[*it] = totalLoad * loadAssignments[*it]/ (instances.size() * loads[*it]);
                        //newLoadAssignments[*it] = (2 - (instances.size() * loadAssignments[*it])) / instances.size();
		}
	}

	normaliseProbabilities(newLoadAssignments);
	updateLoadAssignments(newLoadAssignments);
}

void LoadBalancer::addInstance(InstanceID &inst) {
	if (isMaster) {
		if (instances.find(inst) == instances.end()) {
			if (!rmiRequestAddInstance(inst)) {
				throw SachException("RMI request add instance failed.");
			}

			instances.insert(inst);
			loadMonitor.addInstance(inst);

			balanceLoadsForNewInstance(inst);
		}
	} else {
		throw SachException("Slave calling master function.");
	}
}

void LoadBalancer::removeInstanceWithCoolDown(InstanceID &inst) {
	if (isMaster) {
		if (instances.find(inst) != instances.end()) {
			if (!rmiRequestRemoveInstance(inst)) {
				throw SachException("RMI request remove instance failed.");
			}

			instances.erase(inst);
			loadMonitor.removeInstance(inst);

			balanceLoadsForRemovedInstance(inst);

			coolingDownInstances.insert(
					std::make_pair(inst,
							boost::chrono::high_resolution_clock::now()));
		}
	} else {
		throw SachException("Slave calling master function.");
	}
}

bool LoadBalancer::isActive(InstanceID &inst) {
	if (instances.find(inst) != instances.end()) {
		return true;
	} else if (coolingDownInstances.find(inst) == coolingDownInstances.end()) {
		return false;
	} else {
		timestamp_t duration = (timestamp_t) boost::chrono::duration_cast<
				boost::chrono::milliseconds>(
				boost::chrono::high_resolution_clock::now()
						- coolingDownInstances[inst]).count();
		if (duration > sesManager.getSessionTau()) {
			coolingDownInstances.erase(inst);
			//return true;
                        return false;
		} else {
			//return false;
                        return true;
		}
	}
}
